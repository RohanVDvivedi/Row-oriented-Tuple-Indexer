 * implement 
  * const void* split_insert_*_page(void* page1, uint64_t page1_id, const void* tuple_to_insert, uint32_t tuple_to_insert_at, const bplus_tree_tuple_defs* bpttds, data_access_methods* dam_p /*only required for leaf pages*/);
  * returns pointer to the tuple that needs to be inserted in the parent page

 * implement
  * merge the pages page1 and its immediate next
  * int merge_*_pages(void* page1, uint64_t page1_id, bplus_tree_tuple_defs* bpttds, data_access_methods* dam_p /*only required for leaf pages*/);

 * implement redistribute keys functions

 ***** python pseudo code to inplace split operation (start)
oldPage = [0, 1, 3, 4, 5]
oldPageSize = len(oldPage)
newIndex = 2
newTuple = 2

totalTuples = oldPageSize + 1
tuplesWantedInOldPage = 3
tuplesWantedInNewPage = totalTuples - tuplesWantedInOldPage

newTupleInNewPage = not (newIndex < tuplesWantedInOldPage)

tuplesStaying = 0
if newTupleInNewPage :
    tuplesStaying = tuplesWantedInOldPage
else:
    tuplesStaying = tuplesWantedInOldPage - 1
tuplesLeaving = oldPageSize - tuplesStaying

newPage = []

moveFrom = tuplesStaying
for i in range(moveFrom, oldPageSize) :
    newPage.append(oldPage[i])
    oldPage[i] = -1

if(newTupleInNewPage):
    newPage.insert(newIndex - tuplesStaying, newTuple)
else:
    oldPage.insert(newIndex, newTuple)
        
print(oldPage)
print(newPage)
  ***** python pseudo code to inplace split operation (complete)

 * bplus tree always has a page even if empty and root page's id never changes like that of MySQL
   * implement insert search and delete functionality

 * update implementation of in_memory_data_store to use single mutex lock and a separate condition variables for each page ids. free pages being stored in a heap data structure ordered by their page ids. i.e. allocating lowest page id first and allowing memory store to grow and shrink on demand.