
 * implement 
  * const void* split_insert_interior_page(void* page1, uint64_t page1_id, const void* tuple_to_insert, uint32_t tuple_to_insert_at, const bplus_tree_tuple_defs* bpttds, data_access_methods* dam_p);
  * returns pointer to the index tuple that needs to be inserted in the parent page

 * implement
  * merge the pages page1 and its immediate next
  * int merge_interior_pages(void* page1, uint64_t page1_id, const void* separator_parent_tuple, void* page2, uint64_t page2_id, bplus_tree_tuple_defs* bpttds, data_access_methods* dam_p);
  * separator_parent_tuple is the tuple that separates pointers to page1 and page2 in the parent page
  * returns 1 if the merge was performed, else 0 for a failure

 * implement redistribute keys functions

 * reimplement in_memory_data_store
  * use a single lock and  embedd a reader writer lock inside of it, each page uses a single global mutex for the complete locking mechanism this will keep things simple

 ***** python pseudo code to inplace split operation (start)
oldPage = [0, 1, 3, 4, 5]
oldPageSize = len(oldPage)
newIndex = 2
newTuple = 2

totalTuples = oldPageSize + 1
tuplesWantedInOldPage = 3
tuplesWantedInNewPage = totalTuples - tuplesWantedInOldPage

newTupleInNewPage = not (newIndex < tuplesWantedInOldPage)

tuplesStaying = 0
if newTupleInNewPage :
    tuplesStaying = tuplesWantedInOldPage
else:
    tuplesStaying = tuplesWantedInOldPage - 1
tuplesLeaving = oldPageSize - tuplesStaying

newPage = []

moveFrom = tuplesStaying
for i in range(moveFrom, oldPageSize) :
    newPage.append(oldPage[i])
    oldPage[i] = -1

if(newTupleInNewPage):
    newPage.insert(newIndex - tuplesStaying, newTuple)
else:
    oldPage.insert(newIndex, newTuple)
        
print(oldPage)
print(newPage)
  ***** python pseudo code to inplace split operation (complete)

 * bplus tree always has a page even if empty and root page's id never changes like that of MySQL
   * implement insert, search and delete functionality