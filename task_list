
Stage 1
 * test vigorously the insert and delete functionality
 * upon insert/delete perform compaction by checking the efficiency of the page at random (propbability 0.5) if the efficiency drops below 0.7

Stage 2
 * implement a page_list and a page_cursor interface to read leaf pages list or any page list
   * insert only if tail locked with write, i.e. insert only at the tail
   * read page with seek_page only in one direction
 * use this page_cursor interface to enable range search queries for b+ trees
 * implement support range search and delete queries

STAGE 3
 * create a separate update function, that has int insert_if_absent flag as parameter, this update function can split or merge pages based on size of the new tuple

-- OPTIONAL TASKS BELOW (no to worry about it now) --

STAGE 4
 * external_merge_sort for the page_list
 * building a bplus_tree on top of an external_merge_sorted page_list.
 * persistent storage using bufferpool library, providing a simple data_access_methods