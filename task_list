
Stage 1
 * implement bplus_tree delete function
   * handle edge case of removing the root (only if it is a interior node)
   * handle un latching if the node is more than half full upon removal
   * handle merge with prev for leaf node by correcting the latch acquisition order
   * upon delete perform compaction by checking the efficiency at random
 * make all checks using free space on the page, instead of occupied_tuples_size in storage capacity page_util
 * use in built size checks for split functions, while inserting from temp page to curr_page

STAGE 1.1
 * implement bplus_tree update function
   * insert function will be modified to provide an insert_update like functionality
   * make update_tuple call for updating, if it fails, delete the original tuple and call split_insert. i.e. falling back to insert
   * this is the fastest and best way to implement a update as, update will lead to no memory reclamation for fixed sized records and for slotted page tuple, memory is reclaimed only if we updated the record to a smaller size and it is settled at the end of the page

Stage 2
 * implement a page_list and a page_cursor interface to read leaf pages list or any page list
   * insert only if tail locked with write, i.e. insert only at the tail
   * read page with seek_page only in one direction
 * use this page_cursor interface to enable range search queries for b+ trees
 * implement support range search and delete queries

STAGE 3
 * external_merge_sort for the page_list
 * reverse a sorted page list
 * building a bplus_tree on top of an external_merge_sorted page_list, in multiple runs until there is only 1 page in the tree

-- OPTIONAL TASKS BELOW (no to worry about it now) --

STAGE 4
 * persistent storage using bufferpool library, providing a simple data_access_methods